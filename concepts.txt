Memory Allocations:

Beginning with what you know most :D

i) Dynamic Memory allocation:
    Memory is allocated during runtime and you control the life time of the memory allocated(it's allocated on heap) i.e you are responsible for freeing it when not necessary.

    funct(){
        int *a = new int;    
    }
    
    Here thought the memory has a life time of the entire program but the scope of the reference variable is with in funct hence you cannot access it outside hence a memory leak.

    Heap memory is slower because heap manager has to go through a complicated procedure to find you a contigous chunk of memory of required size wheras allocation on stack is just moving the stack pointer just by the allocated memory value;

ii) Automatic Memory allocation:
    I guess you heard previously that whenever you write something like this 
    int a;
    in a function then you are indirectly meaning auto int a;
    which means auto allocation of memory.
    This is what is known as stack memory and done for local variables. 
    For More about allocation time you need to read more

iii) static Memory Allocation:
    Life time of the memory is the life time of the program similar to the dynamic memory. Static memory allocation happens in .bss section segment (if you remember). All global variables are by default static and for variables to be made static from inside functions c/c++ offers static key word which then allocates and make them static. 
    Even though putting static like
    static int a;
    in a function doesn't make it usable anywhere outside the function but when the control reaches back to the same function you can still access the same memory you have accessed when you have been here previously. 
    "Observe here the difference between scope and life time"

Compile Time Vs Run Time:

    when people say static memory allocations is done during compile time and dynamic is during run time they really mean this
    
    In static memory allocations you know the address of what is present where i.e compiler will be able to compute the addresses and locations but actually memory is allotted during run time.
    Dynamic memory compiler absolutely don't know the address and they are computed in run time when the heap manager gives the memory to the program. 
    
    static variables are initialised to zero i.e the memory that is allocated through static memroy allocation are initialised to zero. Remember they are not allocated on stack. In seperate .bss segment... remember????????????. This is because the assembly code generated by the compiler set's those values in those segment to be zero. As local variables has different address locations internally on the stack though the effective address remains the same i.e relative to base pointer but during functioncalls you may get different address of base pointer and also each time it's not good to initialise all those values if there are thousand calls initialisation each time would be a penality. Whereas static variables happens only once. 


    Actual location of the local variables are only defined with respect to the location of the base pointer. So when all the local variables size is determined then it compiler can give assembly code which directly have addresses i.e relative to base pointer hence this is the problem with dynamic arrays not possible on stack. 


    Memory allocated at compile time actually means "Compiler resolves at compile time where certain things will be allocated  inside the process memory map. 


Arrays and Pointer:
    
    This is hell lot of topic and have bugged hard into this..,

    when you say int arr[10]; 

    Observe following statements carefully.
    1. "Mostly the name of the array resolves to a pointer to first element of the contigous memory location"
    2. "Remember that arrays what ever dimension they may be are contigous storage locations"

    Mostly in the 1st statement seems to be valid when you see this example i.e
    sizeof(arr) here sizeof just doesn't give the size of a pointer but gives you the size of the array. 

    when you declare something like this

   char *str[] = {"forgs", "do", "not", "die"};

   here when you do sizeof(str) would give you 4*(sizeof(char*)) i.e 4*8(64 bit system) i.e 32 since it's an array of char*'s 
   but when you do sizeof(str[0]) it's pointer to some memory location and hence it will give you 8

   Refer this link:http://stackoverflow.com/questions/17564608/what-does-the-array-name-mean-in-case-of-array-of-char-pointers

    char str[] = {'a','b','c'};
    doing str[1]='A'; is valid

    but when you do char *str = "abc";
    now doing str[1] = 'A' is an error as you didn't allocate memory for string abc and it is on readonly segment hence you cannot overwrite. Allocate memory only then you get both read and write access.

